{"version":3,"file":"vendor_doctrine-418f7cf8.js","sources":["../../node_modules/doctrine/lib/utility.js","../../node_modules/doctrine/lib/typed.js","../../node_modules/doctrine/lib/doctrine.js"],"sourcesContent":["/*\n * @fileoverview Utilities for Doctrine\n * @author Yusuke Suzuki <utatane.tea@gmail.com>\n */\n\n\n(function () {\n    'use strict';\n\n    var VERSION;\n\n    VERSION = require('../package.json').version;\n    exports.VERSION = VERSION;\n\n    function DoctrineError(message) {\n        this.name = 'DoctrineError';\n        this.message = message;\n    }\n    DoctrineError.prototype = (function () {\n        var Middle = function () { };\n        Middle.prototype = Error.prototype;\n        return new Middle();\n    }());\n    DoctrineError.prototype.constructor = DoctrineError;\n    exports.DoctrineError = DoctrineError;\n\n    function throwError(message) {\n        throw new DoctrineError(message);\n    }\n    exports.throwError = throwError;\n\n    exports.assert = require('assert');\n}());\n\n/* vim: set sw=4 ts=4 et tw=80 : */\n","/*\n * @fileoverview Type expression parser.\n * @author Yusuke Suzuki <utatane.tea@gmail.com>\n * @author Dan Tao <daniel.tao@gmail.com>\n * @author Andrew Eisenberg <andrew@eisenberg.as>\n */\n\n// \"typed\", the Type Expression Parser for doctrine.\n\n(function () {\n    'use strict';\n\n    var Syntax,\n        Token,\n        source,\n        length,\n        index,\n        previous,\n        token,\n        value,\n        esutils,\n        utility,\n        rangeOffset,\n        addRange;\n\n    esutils = require('esutils');\n    utility = require('./utility');\n\n    Syntax = {\n        NullableLiteral: 'NullableLiteral',\n        AllLiteral: 'AllLiteral',\n        NullLiteral: 'NullLiteral',\n        UndefinedLiteral: 'UndefinedLiteral',\n        VoidLiteral: 'VoidLiteral',\n        UnionType: 'UnionType',\n        ArrayType: 'ArrayType',\n        RecordType: 'RecordType',\n        FieldType: 'FieldType',\n        FunctionType: 'FunctionType',\n        ParameterType: 'ParameterType',\n        RestType: 'RestType',\n        NonNullableType: 'NonNullableType',\n        OptionalType: 'OptionalType',\n        NullableType: 'NullableType',\n        NameExpression: 'NameExpression',\n        TypeApplication: 'TypeApplication',\n        StringLiteralType: 'StringLiteralType',\n        NumericLiteralType: 'NumericLiteralType',\n        BooleanLiteralType: 'BooleanLiteralType'\n    };\n\n    Token = {\n        ILLEGAL: 0,    // ILLEGAL\n        DOT_LT: 1,     // .<\n        REST: 2,       // ...\n        LT: 3,         // <\n        GT: 4,         // >\n        LPAREN: 5,     // (\n        RPAREN: 6,     // )\n        LBRACE: 7,     // {\n        RBRACE: 8,     // }\n        LBRACK: 9,    // [\n        RBRACK: 10,    // ]\n        COMMA: 11,     // ,\n        COLON: 12,     // :\n        STAR: 13,      // *\n        PIPE: 14,      // |\n        QUESTION: 15,  // ?\n        BANG: 16,      // !\n        EQUAL: 17,     // =\n        NAME: 18,      // name token\n        STRING: 19,    // string\n        NUMBER: 20,    // number\n        EOF: 21\n    };\n\n    function isTypeName(ch) {\n        return '><(){}[],:*|?!='.indexOf(String.fromCharCode(ch)) === -1 && !esutils.code.isWhiteSpace(ch) && !esutils.code.isLineTerminator(ch);\n    }\n\n    function Context(previous, index, token, value) {\n        this._previous = previous;\n        this._index = index;\n        this._token = token;\n        this._value = value;\n    }\n\n    Context.prototype.restore = function () {\n        previous = this._previous;\n        index = this._index;\n        token = this._token;\n        value = this._value;\n    };\n\n    Context.save = function () {\n        return new Context(previous, index, token, value);\n    };\n\n    function maybeAddRange(node, range) {\n        if (addRange) {\n            node.range = [range[0] + rangeOffset, range[1] + rangeOffset];\n        }\n        return node;\n    }\n\n    function advance() {\n        var ch = source.charAt(index);\n        index += 1;\n        return ch;\n    }\n\n    function scanHexEscape(prefix) {\n        var i, len, ch, code = 0;\n\n        len = (prefix === 'u') ? 4 : 2;\n        for (i = 0; i < len; ++i) {\n            if (index < length && esutils.code.isHexDigit(source.charCodeAt(index))) {\n                ch = advance();\n                code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n            } else {\n                return '';\n            }\n        }\n        return String.fromCharCode(code);\n    }\n\n    function scanString() {\n        var str = '', quote, ch, code, unescaped, restore; //TODO review removal octal = false\n        quote = source.charAt(index);\n        ++index;\n\n        while (index < length) {\n            ch = advance();\n\n            if (ch === quote) {\n                quote = '';\n                break;\n            } else if (ch === '\\\\') {\n                ch = advance();\n                if (!esutils.code.isLineTerminator(ch.charCodeAt(0))) {\n                    switch (ch) {\n                    case 'n':\n                        str += '\\n';\n                        break;\n                    case 'r':\n                        str += '\\r';\n                        break;\n                    case 't':\n                        str += '\\t';\n                        break;\n                    case 'u':\n                    case 'x':\n                        restore = index;\n                        unescaped = scanHexEscape(ch);\n                        if (unescaped) {\n                            str += unescaped;\n                        } else {\n                            index = restore;\n                            str += ch;\n                        }\n                        break;\n                    case 'b':\n                        str += '\\b';\n                        break;\n                    case 'f':\n                        str += '\\f';\n                        break;\n                    case 'v':\n                        str += '\\v';\n                        break;\n\n                    default:\n                        if (esutils.code.isOctalDigit(ch.charCodeAt(0))) {\n                            code = '01234567'.indexOf(ch);\n\n                            // \\0 is not octal escape sequence\n                            // Deprecating unused code. TODO review removal\n                            //if (code !== 0) {\n                            //    octal = true;\n                            //}\n\n                            if (index < length && esutils.code.isOctalDigit(source.charCodeAt(index))) {\n                                //TODO Review Removal octal = true;\n                                code = code * 8 + '01234567'.indexOf(advance());\n\n                                // 3 digits are only allowed when string starts\n                                // with 0, 1, 2, 3\n                                if ('0123'.indexOf(ch) >= 0 &&\n                                        index < length &&\n                                        esutils.code.isOctalDigit(source.charCodeAt(index))) {\n                                    code = code * 8 + '01234567'.indexOf(advance());\n                                }\n                            }\n                            str += String.fromCharCode(code);\n                        } else {\n                            str += ch;\n                        }\n                        break;\n                    }\n                } else {\n                    if (ch ===  '\\r' && source.charCodeAt(index) === 0x0A  /* '\\n' */) {\n                        ++index;\n                    }\n                }\n            } else if (esutils.code.isLineTerminator(ch.charCodeAt(0))) {\n                break;\n            } else {\n                str += ch;\n            }\n        }\n\n        if (quote !== '') {\n            utility.throwError('unexpected quote');\n        }\n\n        value = str;\n        return Token.STRING;\n    }\n\n    function scanNumber() {\n        var number, ch;\n\n        number = '';\n        ch = source.charCodeAt(index);\n\n        if (ch !== 0x2E  /* '.' */) {\n            number = advance();\n            ch = source.charCodeAt(index);\n\n            if (number === '0') {\n                if (ch === 0x78  /* 'x' */ || ch === 0x58  /* 'X' */) {\n                    number += advance();\n                    while (index < length) {\n                        ch = source.charCodeAt(index);\n                        if (!esutils.code.isHexDigit(ch)) {\n                            break;\n                        }\n                        number += advance();\n                    }\n\n                    if (number.length <= 2) {\n                        // only 0x\n                        utility.throwError('unexpected token');\n                    }\n\n                    if (index < length) {\n                        ch = source.charCodeAt(index);\n                        if (esutils.code.isIdentifierStartES5(ch)) {\n                            utility.throwError('unexpected token');\n                        }\n                    }\n                    value = parseInt(number, 16);\n                    return Token.NUMBER;\n                }\n\n                if (esutils.code.isOctalDigit(ch)) {\n                    number += advance();\n                    while (index < length) {\n                        ch = source.charCodeAt(index);\n                        if (!esutils.code.isOctalDigit(ch)) {\n                            break;\n                        }\n                        number += advance();\n                    }\n\n                    if (index < length) {\n                        ch = source.charCodeAt(index);\n                        if (esutils.code.isIdentifierStartES5(ch) || esutils.code.isDecimalDigit(ch)) {\n                            utility.throwError('unexpected token');\n                        }\n                    }\n                    value = parseInt(number, 8);\n                    return Token.NUMBER;\n                }\n\n                if (esutils.code.isDecimalDigit(ch)) {\n                    utility.throwError('unexpected token');\n                }\n            }\n\n            while (index < length) {\n                ch = source.charCodeAt(index);\n                if (!esutils.code.isDecimalDigit(ch)) {\n                    break;\n                }\n                number += advance();\n            }\n        }\n\n        if (ch === 0x2E  /* '.' */) {\n            number += advance();\n            while (index < length) {\n                ch = source.charCodeAt(index);\n                if (!esutils.code.isDecimalDigit(ch)) {\n                    break;\n                }\n                number += advance();\n            }\n        }\n\n        if (ch === 0x65  /* 'e' */ || ch === 0x45  /* 'E' */) {\n            number += advance();\n\n            ch = source.charCodeAt(index);\n            if (ch === 0x2B  /* '+' */ || ch === 0x2D  /* '-' */) {\n                number += advance();\n            }\n\n            ch = source.charCodeAt(index);\n            if (esutils.code.isDecimalDigit(ch)) {\n                number += advance();\n                while (index < length) {\n                    ch = source.charCodeAt(index);\n                    if (!esutils.code.isDecimalDigit(ch)) {\n                        break;\n                    }\n                    number += advance();\n                }\n            } else {\n                utility.throwError('unexpected token');\n            }\n        }\n\n        if (index < length) {\n            ch = source.charCodeAt(index);\n            if (esutils.code.isIdentifierStartES5(ch)) {\n                utility.throwError('unexpected token');\n            }\n        }\n\n        value = parseFloat(number);\n        return Token.NUMBER;\n    }\n\n\n    function scanTypeName() {\n        var ch, ch2;\n\n        value = advance();\n        while (index < length && isTypeName(source.charCodeAt(index))) {\n            ch = source.charCodeAt(index);\n            if (ch === 0x2E  /* '.' */) {\n                if ((index + 1) >= length) {\n                    return Token.ILLEGAL;\n                }\n                ch2 = source.charCodeAt(index + 1);\n                if (ch2 === 0x3C  /* '<' */) {\n                    break;\n                }\n            }\n            value += advance();\n        }\n        return Token.NAME;\n    }\n\n    function next() {\n        var ch;\n\n        previous = index;\n\n        while (index < length && esutils.code.isWhiteSpace(source.charCodeAt(index))) {\n            advance();\n        }\n        if (index >= length) {\n            token = Token.EOF;\n            return token;\n        }\n\n        ch = source.charCodeAt(index);\n        switch (ch) {\n        case 0x27:  /* ''' */\n        case 0x22:  /* '\"' */\n            token = scanString();\n            return token;\n\n        case 0x3A:  /* ':' */\n            advance();\n            token = Token.COLON;\n            return token;\n\n        case 0x2C:  /* ',' */\n            advance();\n            token = Token.COMMA;\n            return token;\n\n        case 0x28:  /* '(' */\n            advance();\n            token = Token.LPAREN;\n            return token;\n\n        case 0x29:  /* ')' */\n            advance();\n            token = Token.RPAREN;\n            return token;\n\n        case 0x5B:  /* '[' */\n            advance();\n            token = Token.LBRACK;\n            return token;\n\n        case 0x5D:  /* ']' */\n            advance();\n            token = Token.RBRACK;\n            return token;\n\n        case 0x7B:  /* '{' */\n            advance();\n            token = Token.LBRACE;\n            return token;\n\n        case 0x7D:  /* '}' */\n            advance();\n            token = Token.RBRACE;\n            return token;\n\n        case 0x2E:  /* '.' */\n            if (index + 1 < length) {\n                ch = source.charCodeAt(index + 1);\n                if (ch === 0x3C  /* '<' */) {\n                    advance();  // '.'\n                    advance();  // '<'\n                    token = Token.DOT_LT;\n                    return token;\n                }\n\n                if (ch === 0x2E  /* '.' */ && index + 2 < length && source.charCodeAt(index + 2) === 0x2E  /* '.' */) {\n                    advance();  // '.'\n                    advance();  // '.'\n                    advance();  // '.'\n                    token = Token.REST;\n                    return token;\n                }\n\n                if (esutils.code.isDecimalDigit(ch)) {\n                    token = scanNumber();\n                    return token;\n                }\n            }\n            token = Token.ILLEGAL;\n            return token;\n\n        case 0x3C:  /* '<' */\n            advance();\n            token = Token.LT;\n            return token;\n\n        case 0x3E:  /* '>' */\n            advance();\n            token = Token.GT;\n            return token;\n\n        case 0x2A:  /* '*' */\n            advance();\n            token = Token.STAR;\n            return token;\n\n        case 0x7C:  /* '|' */\n            advance();\n            token = Token.PIPE;\n            return token;\n\n        case 0x3F:  /* '?' */\n            advance();\n            token = Token.QUESTION;\n            return token;\n\n        case 0x21:  /* '!' */\n            advance();\n            token = Token.BANG;\n            return token;\n\n        case 0x3D:  /* '=' */\n            advance();\n            token = Token.EQUAL;\n            return token;\n\n        case 0x2D: /* '-' */\n            token = scanNumber();\n            return token;\n\n        default:\n            if (esutils.code.isDecimalDigit(ch)) {\n                token = scanNumber();\n                return token;\n            }\n\n            // type string permits following case,\n            //\n            // namespace.module.MyClass\n            //\n            // this reduced 1 token TK_NAME\n            utility.assert(isTypeName(ch));\n            token = scanTypeName();\n            return token;\n        }\n    }\n\n    function consume(target, text) {\n        utility.assert(token === target, text || 'consumed token not matched');\n        next();\n    }\n\n    function expect(target, message) {\n        if (token !== target) {\n            utility.throwError(message || 'unexpected token');\n        }\n        next();\n    }\n\n    // UnionType := '(' TypeUnionList ')'\n    //\n    // TypeUnionList :=\n    //     <<empty>>\n    //   | NonemptyTypeUnionList\n    //\n    // NonemptyTypeUnionList :=\n    //     TypeExpression\n    //   | TypeExpression '|' NonemptyTypeUnionList\n    function parseUnionType() {\n        var elements, startIndex = index - 1;\n        consume(Token.LPAREN, 'UnionType should start with (');\n        elements = [];\n        if (token !== Token.RPAREN) {\n            while (true) {\n                elements.push(parseTypeExpression());\n                if (token === Token.RPAREN) {\n                    break;\n                }\n                expect(Token.PIPE);\n            }\n        }\n        consume(Token.RPAREN, 'UnionType should end with )');\n        return maybeAddRange({\n            type: Syntax.UnionType,\n            elements: elements\n        }, [startIndex, previous]);\n    }\n\n    // ArrayType := '[' ElementTypeList ']'\n    //\n    // ElementTypeList :=\n    //     <<empty>>\n    //  | TypeExpression\n    //  | '...' TypeExpression\n    //  | TypeExpression ',' ElementTypeList\n    function parseArrayType() {\n        var elements, startIndex = index - 1, restStartIndex;\n        consume(Token.LBRACK, 'ArrayType should start with [');\n        elements = [];\n        while (token !== Token.RBRACK) {\n            if (token === Token.REST) {\n                restStartIndex = index - 3;\n                consume(Token.REST);\n                elements.push(maybeAddRange({\n                    type: Syntax.RestType,\n                    expression: parseTypeExpression()\n                }, [restStartIndex, previous]));\n                break;\n            } else {\n                elements.push(parseTypeExpression());\n            }\n            if (token !== Token.RBRACK) {\n                expect(Token.COMMA);\n            }\n        }\n        expect(Token.RBRACK);\n        return maybeAddRange({\n            type: Syntax.ArrayType,\n            elements: elements\n        }, [startIndex, previous]);\n    }\n\n    function parseFieldName() {\n        var v = value;\n        if (token === Token.NAME || token === Token.STRING) {\n            next();\n            return v;\n        }\n\n        if (token === Token.NUMBER) {\n            consume(Token.NUMBER);\n            return String(v);\n        }\n\n        utility.throwError('unexpected token');\n    }\n\n    // FieldType :=\n    //     FieldName\n    //   | FieldName ':' TypeExpression\n    //\n    // FieldName :=\n    //     NameExpression\n    //   | StringLiteral\n    //   | NumberLiteral\n    //   | ReservedIdentifier\n    function parseFieldType() {\n        var key, rangeStart = previous;\n\n        key = parseFieldName();\n        if (token === Token.COLON) {\n            consume(Token.COLON);\n            return maybeAddRange({\n                type: Syntax.FieldType,\n                key: key,\n                value: parseTypeExpression()\n            }, [rangeStart, previous]);\n        }\n        return maybeAddRange({\n            type: Syntax.FieldType,\n            key: key,\n            value: null\n        }, [rangeStart, previous]);\n    }\n\n    // RecordType := '{' FieldTypeList '}'\n    //\n    // FieldTypeList :=\n    //     <<empty>>\n    //   | FieldType\n    //   | FieldType ',' FieldTypeList\n    function parseRecordType() {\n        var fields, rangeStart = index - 1, rangeEnd;\n\n        consume(Token.LBRACE, 'RecordType should start with {');\n        fields = [];\n        if (token === Token.COMMA) {\n            consume(Token.COMMA);\n        } else {\n            while (token !== Token.RBRACE) {\n                fields.push(parseFieldType());\n                if (token !== Token.RBRACE) {\n                    expect(Token.COMMA);\n                }\n            }\n        }\n        rangeEnd = index;\n        expect(Token.RBRACE);\n        return maybeAddRange({\n            type: Syntax.RecordType,\n            fields: fields\n        }, [rangeStart, rangeEnd]);\n    }\n\n    // NameExpression :=\n    //    Identifier\n    //  | TagIdentifier ':' Identifier\n    //\n    // Tag identifier is one of \"module\", \"external\" or \"event\"\n    // Identifier is the same as Token.NAME, including any dots, something like\n    // namespace.module.MyClass\n    function parseNameExpression() {\n        var name = value, rangeStart = index - name.length;\n        expect(Token.NAME);\n\n        if (token === Token.COLON && (\n                name === 'module' ||\n                name === 'external' ||\n                name === 'event')) {\n            consume(Token.COLON);\n            name += ':' + value;\n            expect(Token.NAME);\n        }\n\n        return maybeAddRange({\n            type: Syntax.NameExpression,\n            name: name\n        }, [rangeStart, previous]);\n    }\n\n    // TypeExpressionList :=\n    //     TopLevelTypeExpression\n    //   | TopLevelTypeExpression ',' TypeExpressionList\n    function parseTypeExpressionList() {\n        var elements = [];\n\n        elements.push(parseTop());\n        while (token === Token.COMMA) {\n            consume(Token.COMMA);\n            elements.push(parseTop());\n        }\n        return elements;\n    }\n\n    // TypeName :=\n    //     NameExpression\n    //   | NameExpression TypeApplication\n    //\n    // TypeApplication :=\n    //     '.<' TypeExpressionList '>'\n    //   | '<' TypeExpressionList '>'   // this is extension of doctrine\n    function parseTypeName() {\n        var expr, applications, startIndex = index - value.length;\n\n        expr = parseNameExpression();\n        if (token === Token.DOT_LT || token === Token.LT) {\n            next();\n            applications = parseTypeExpressionList();\n            expect(Token.GT);\n            return maybeAddRange({\n                type: Syntax.TypeApplication,\n                expression: expr,\n                applications: applications\n            }, [startIndex, previous]);\n        }\n        return expr;\n    }\n\n    // ResultType :=\n    //     <<empty>>\n    //   | ':' void\n    //   | ':' TypeExpression\n    //\n    // BNF is above\n    // but, we remove <<empty>> pattern, so token is always TypeToken::COLON\n    function parseResultType() {\n        consume(Token.COLON, 'ResultType should start with :');\n        if (token === Token.NAME && value === 'void') {\n            consume(Token.NAME);\n            return {\n                type: Syntax.VoidLiteral\n            };\n        }\n        return parseTypeExpression();\n    }\n\n    // ParametersType :=\n    //     RestParameterType\n    //   | NonRestParametersType\n    //   | NonRestParametersType ',' RestParameterType\n    //\n    // RestParameterType :=\n    //     '...'\n    //     '...' Identifier\n    //\n    // NonRestParametersType :=\n    //     ParameterType ',' NonRestParametersType\n    //   | ParameterType\n    //   | OptionalParametersType\n    //\n    // OptionalParametersType :=\n    //     OptionalParameterType\n    //   | OptionalParameterType, OptionalParametersType\n    //\n    // OptionalParameterType := ParameterType=\n    //\n    // ParameterType := TypeExpression | Identifier ':' TypeExpression\n    //\n    // Identifier is \"new\" or \"this\"\n    function parseParametersType() {\n        var params = [], optionalSequence = false, expr, rest = false, startIndex, restStartIndex = index - 3, nameStartIndex;\n\n        while (token !== Token.RPAREN) {\n            if (token === Token.REST) {\n                // RestParameterType\n                consume(Token.REST);\n                rest = true;\n            }\n\n            startIndex = previous;\n\n            expr = parseTypeExpression();\n            if (expr.type === Syntax.NameExpression && token === Token.COLON) {\n                nameStartIndex = previous - expr.name.length;\n                // Identifier ':' TypeExpression\n                consume(Token.COLON);\n                expr = maybeAddRange({\n                    type: Syntax.ParameterType,\n                    name: expr.name,\n                    expression: parseTypeExpression()\n                }, [nameStartIndex, previous]);\n            }\n            if (token === Token.EQUAL) {\n                consume(Token.EQUAL);\n                expr = maybeAddRange({\n                    type: Syntax.OptionalType,\n                    expression: expr\n                }, [startIndex, previous]);\n                optionalSequence = true;\n            } else {\n                if (optionalSequence) {\n                    utility.throwError('unexpected token');\n                }\n            }\n            if (rest) {\n                expr = maybeAddRange({\n                    type: Syntax.RestType,\n                    expression: expr\n                }, [restStartIndex, previous]);\n            }\n            params.push(expr);\n            if (token !== Token.RPAREN) {\n                expect(Token.COMMA);\n            }\n        }\n        return params;\n    }\n\n    // FunctionType := 'function' FunctionSignatureType\n    //\n    // FunctionSignatureType :=\n    //   | TypeParameters '(' ')' ResultType\n    //   | TypeParameters '(' ParametersType ')' ResultType\n    //   | TypeParameters '(' 'this' ':' TypeName ')' ResultType\n    //   | TypeParameters '(' 'this' ':' TypeName ',' ParametersType ')' ResultType\n    function parseFunctionType() {\n        var isNew, thisBinding, params, result, fnType, startIndex = index - value.length;\n        utility.assert(token === Token.NAME && value === 'function', 'FunctionType should start with \\'function\\'');\n        consume(Token.NAME);\n\n        // Google Closure Compiler is not implementing TypeParameters.\n        // So we do not. if we don't get '(', we see it as error.\n        expect(Token.LPAREN);\n\n        isNew = false;\n        params = [];\n        thisBinding = null;\n        if (token !== Token.RPAREN) {\n            // ParametersType or 'this'\n            if (token === Token.NAME &&\n                    (value === 'this' || value === 'new')) {\n                // 'this' or 'new'\n                // 'new' is Closure Compiler extension\n                isNew = value === 'new';\n                consume(Token.NAME);\n                expect(Token.COLON);\n                thisBinding = parseTypeName();\n                if (token === Token.COMMA) {\n                    consume(Token.COMMA);\n                    params = parseParametersType();\n                }\n            } else {\n                params = parseParametersType();\n            }\n        }\n\n        expect(Token.RPAREN);\n\n        result = null;\n        if (token === Token.COLON) {\n            result = parseResultType();\n        }\n\n        fnType = maybeAddRange({\n            type: Syntax.FunctionType,\n            params: params,\n            result: result\n        }, [startIndex, previous]);\n        if (thisBinding) {\n            // avoid adding null 'new' and 'this' properties\n            fnType['this'] = thisBinding;\n            if (isNew) {\n                fnType['new'] = true;\n            }\n        }\n        return fnType;\n    }\n\n    // BasicTypeExpression :=\n    //     '*'\n    //   | 'null'\n    //   | 'undefined'\n    //   | TypeName\n    //   | FunctionType\n    //   | UnionType\n    //   | RecordType\n    //   | ArrayType\n    function parseBasicTypeExpression() {\n        var context, startIndex;\n        switch (token) {\n        case Token.STAR:\n            consume(Token.STAR);\n            return maybeAddRange({\n                type: Syntax.AllLiteral\n            }, [previous - 1, previous]);\n\n        case Token.LPAREN:\n            return parseUnionType();\n\n        case Token.LBRACK:\n            return parseArrayType();\n\n        case Token.LBRACE:\n            return parseRecordType();\n\n        case Token.NAME:\n            startIndex = index - value.length;\n\n            if (value === 'null') {\n                consume(Token.NAME);\n                return maybeAddRange({\n                    type: Syntax.NullLiteral\n                }, [startIndex, previous]);\n            }\n\n            if (value === 'undefined') {\n                consume(Token.NAME);\n                return maybeAddRange({\n                    type: Syntax.UndefinedLiteral\n                }, [startIndex, previous]);\n            }\n\n            if (value === 'true' || value === 'false') {\n                consume(Token.NAME);\n                return maybeAddRange({\n                    type: Syntax.BooleanLiteralType,\n                    value: value === 'true'\n                }, [startIndex, previous]);\n            }\n\n            context = Context.save();\n            if (value === 'function') {\n                try {\n                    return parseFunctionType();\n                } catch (e) {\n                    context.restore();\n                }\n            }\n\n            return parseTypeName();\n\n        case Token.STRING:\n            next();\n            return maybeAddRange({\n                type: Syntax.StringLiteralType,\n                value: value\n            }, [previous - value.length - 2, previous]);\n\n        case Token.NUMBER:\n            next();\n            return maybeAddRange({\n                type: Syntax.NumericLiteralType,\n                value: value\n            }, [previous - String(value).length, previous]);\n\n        default:\n            utility.throwError('unexpected token');\n        }\n    }\n\n    // TypeExpression :=\n    //     BasicTypeExpression\n    //   | '?' BasicTypeExpression\n    //   | '!' BasicTypeExpression\n    //   | BasicTypeExpression '?'\n    //   | BasicTypeExpression '!'\n    //   | '?'\n    //   | BasicTypeExpression '[]'\n    function parseTypeExpression() {\n        var expr, rangeStart;\n\n        if (token === Token.QUESTION) {\n            rangeStart = index - 1;\n            consume(Token.QUESTION);\n            if (token === Token.COMMA || token === Token.EQUAL || token === Token.RBRACE ||\n                    token === Token.RPAREN || token === Token.PIPE || token === Token.EOF ||\n                    token === Token.RBRACK || token === Token.GT) {\n                return maybeAddRange({\n                    type: Syntax.NullableLiteral\n                }, [rangeStart, previous]);\n            }\n            return maybeAddRange({\n                type: Syntax.NullableType,\n                expression: parseBasicTypeExpression(),\n                prefix: true\n            }, [rangeStart, previous]);\n        } else if (token === Token.BANG) {\n            rangeStart = index - 1;\n            consume(Token.BANG);\n            return maybeAddRange({\n                type: Syntax.NonNullableType,\n                expression: parseBasicTypeExpression(),\n                prefix: true\n            }, [rangeStart, previous]);\n        } else {\n            rangeStart = previous;\n        }\n\n        expr = parseBasicTypeExpression();\n        if (token === Token.BANG) {\n            consume(Token.BANG);\n            return maybeAddRange({\n                type: Syntax.NonNullableType,\n                expression: expr,\n                prefix: false\n            }, [rangeStart, previous]);\n        }\n\n        if (token === Token.QUESTION) {\n            consume(Token.QUESTION);\n            return maybeAddRange({\n                type: Syntax.NullableType,\n                expression: expr,\n                prefix: false\n            }, [rangeStart, previous]);\n        }\n\n        if (token === Token.LBRACK) {\n            consume(Token.LBRACK);\n            expect(Token.RBRACK, 'expected an array-style type declaration (' + value + '[])');\n            return maybeAddRange({\n                type: Syntax.TypeApplication,\n                expression: maybeAddRange({\n                    type: Syntax.NameExpression,\n                    name: 'Array'\n                }, [rangeStart, previous]),\n                applications: [expr]\n            }, [rangeStart, previous]);\n        }\n\n        return expr;\n    }\n\n    // TopLevelTypeExpression :=\n    //      TypeExpression\n    //    | TypeUnionList\n    //\n    // This rule is Google Closure Compiler extension, not ES4\n    // like,\n    //   { number | string }\n    // If strict to ES4, we should write it as\n    //   { (number|string) }\n    function parseTop() {\n        var expr, elements;\n\n        expr = parseTypeExpression();\n        if (token !== Token.PIPE) {\n            return expr;\n        }\n\n        elements = [expr];\n        consume(Token.PIPE);\n        while (true) {\n            elements.push(parseTypeExpression());\n            if (token !== Token.PIPE) {\n                break;\n            }\n            consume(Token.PIPE);\n        }\n\n        return maybeAddRange({\n            type: Syntax.UnionType,\n            elements: elements\n        }, [0, index]);\n    }\n\n    function parseTopParamType() {\n        var expr;\n\n        if (token === Token.REST) {\n            consume(Token.REST);\n            return maybeAddRange({\n                type: Syntax.RestType,\n                expression: parseTop()\n            }, [0, index]);\n        }\n\n        expr = parseTop();\n        if (token === Token.EQUAL) {\n            consume(Token.EQUAL);\n            return maybeAddRange({\n                type: Syntax.OptionalType,\n                expression: expr\n            }, [0, index]);\n        }\n\n        return expr;\n    }\n\n    function parseType(src, opt) {\n        var expr;\n\n        source = src;\n        length = source.length;\n        index = 0;\n        previous = 0;\n        addRange = opt && opt.range;\n        rangeOffset = opt && opt.startIndex || 0;\n\n        next();\n        expr = parseTop();\n\n        if (opt && opt.midstream) {\n            return {\n                expression: expr,\n                index: previous\n            };\n        }\n\n        if (token !== Token.EOF) {\n            utility.throwError('not reach to EOF');\n        }\n\n        return expr;\n    }\n\n    function parseParamType(src, opt) {\n        var expr;\n\n        source = src;\n        length = source.length;\n        index = 0;\n        previous = 0;\n        addRange = opt && opt.range;\n        rangeOffset = opt && opt.startIndex || 0;\n\n        next();\n        expr = parseTopParamType();\n\n        if (opt && opt.midstream) {\n            return {\n                expression: expr,\n                index: previous\n            };\n        }\n\n        if (token !== Token.EOF) {\n            utility.throwError('not reach to EOF');\n        }\n\n        return expr;\n    }\n\n    function stringifyImpl(node, compact, topLevel) {\n        var result, i, iz;\n\n        switch (node.type) {\n        case Syntax.NullableLiteral:\n            result = '?';\n            break;\n\n        case Syntax.AllLiteral:\n            result = '*';\n            break;\n\n        case Syntax.NullLiteral:\n            result = 'null';\n            break;\n\n        case Syntax.UndefinedLiteral:\n            result = 'undefined';\n            break;\n\n        case Syntax.VoidLiteral:\n            result = 'void';\n            break;\n\n        case Syntax.UnionType:\n            if (!topLevel) {\n                result = '(';\n            } else {\n                result = '';\n            }\n\n            for (i = 0, iz = node.elements.length; i < iz; ++i) {\n                result += stringifyImpl(node.elements[i], compact);\n                if ((i + 1) !== iz) {\n                    result += compact ? '|' : ' | ';\n                }\n            }\n\n            if (!topLevel) {\n                result += ')';\n            }\n            break;\n\n        case Syntax.ArrayType:\n            result = '[';\n            for (i = 0, iz = node.elements.length; i < iz; ++i) {\n                result += stringifyImpl(node.elements[i], compact);\n                if ((i + 1) !== iz) {\n                    result += compact ? ',' : ', ';\n                }\n            }\n            result += ']';\n            break;\n\n        case Syntax.RecordType:\n            result = '{';\n            for (i = 0, iz = node.fields.length; i < iz; ++i) {\n                result += stringifyImpl(node.fields[i], compact);\n                if ((i + 1) !== iz) {\n                    result += compact ? ',' : ', ';\n                }\n            }\n            result += '}';\n            break;\n\n        case Syntax.FieldType:\n            if (node.value) {\n                result = node.key + (compact ? ':' : ': ') + stringifyImpl(node.value, compact);\n            } else {\n                result = node.key;\n            }\n            break;\n\n        case Syntax.FunctionType:\n            result = compact ? 'function(' : 'function (';\n\n            if (node['this']) {\n                if (node['new']) {\n                    result += (compact ? 'new:' : 'new: ');\n                } else {\n                    result += (compact ? 'this:' : 'this: ');\n                }\n\n                result += stringifyImpl(node['this'], compact);\n\n                if (node.params.length !== 0) {\n                    result += compact ? ',' : ', ';\n                }\n            }\n\n            for (i = 0, iz = node.params.length; i < iz; ++i) {\n                result += stringifyImpl(node.params[i], compact);\n                if ((i + 1) !== iz) {\n                    result += compact ? ',' : ', ';\n                }\n            }\n\n            result += ')';\n\n            if (node.result) {\n                result += (compact ? ':' : ': ') + stringifyImpl(node.result, compact);\n            }\n            break;\n\n        case Syntax.ParameterType:\n            result = node.name + (compact ? ':' : ': ') + stringifyImpl(node.expression, compact);\n            break;\n\n        case Syntax.RestType:\n            result = '...';\n            if (node.expression) {\n                result += stringifyImpl(node.expression, compact);\n            }\n            break;\n\n        case Syntax.NonNullableType:\n            if (node.prefix) {\n                result = '!' + stringifyImpl(node.expression, compact);\n            } else {\n                result = stringifyImpl(node.expression, compact) + '!';\n            }\n            break;\n\n        case Syntax.OptionalType:\n            result = stringifyImpl(node.expression, compact) + '=';\n            break;\n\n        case Syntax.NullableType:\n            if (node.prefix) {\n                result = '?' + stringifyImpl(node.expression, compact);\n            } else {\n                result = stringifyImpl(node.expression, compact) + '?';\n            }\n            break;\n\n        case Syntax.NameExpression:\n            result = node.name;\n            break;\n\n        case Syntax.TypeApplication:\n            result = stringifyImpl(node.expression, compact) + '.<';\n            for (i = 0, iz = node.applications.length; i < iz; ++i) {\n                result += stringifyImpl(node.applications[i], compact);\n                if ((i + 1) !== iz) {\n                    result += compact ? ',' : ', ';\n                }\n            }\n            result += '>';\n            break;\n\n        case Syntax.StringLiteralType:\n            result = '\"' + node.value + '\"';\n            break;\n\n        case Syntax.NumericLiteralType:\n            result = String(node.value);\n            break;\n\n        case Syntax.BooleanLiteralType:\n            result = String(node.value);\n            break;\n\n        default:\n            utility.throwError('Unknown type ' + node.type);\n        }\n\n        return result;\n    }\n\n    function stringify(node, options) {\n        if (options == null) {\n            options = {};\n        }\n        return stringifyImpl(node, options.compact, options.topLevel);\n    }\n\n    exports.parseType = parseType;\n    exports.parseParamType = parseParamType;\n    exports.stringify = stringify;\n    exports.Syntax = Syntax;\n}());\n/* vim: set sw=4 ts=4 et tw=80 : */\n","/*\n * @fileoverview Main Doctrine object\n * @author Yusuke Suzuki <utatane.tea@gmail.com>\n * @author Dan Tao <daniel.tao@gmail.com>\n * @author Andrew Eisenberg <andrew@eisenberg.as>\n */\n\n(function () {\n    'use strict';\n\n    var typed,\n        utility,\n        jsdoc,\n        esutils,\n        hasOwnProperty;\n\n    esutils = require('esutils');\n    typed = require('./typed');\n    utility = require('./utility');\n\n    function sliceSource(source, index, last) {\n        return source.slice(index, last);\n    }\n\n    hasOwnProperty = (function () {\n        var func = Object.prototype.hasOwnProperty;\n        return function hasOwnProperty(obj, name) {\n            return func.call(obj, name);\n        };\n    }());\n    function shallowCopy(obj) {\n        var ret = {}, key;\n        for (key in obj) {\n            if (obj.hasOwnProperty(key)) {\n                ret[key] = obj[key];\n            }\n        }\n        return ret;\n    }\n\n    function isASCIIAlphanumeric(ch) {\n        return (ch >= 0x61  /* 'a' */ && ch <= 0x7A  /* 'z' */) ||\n            (ch >= 0x41  /* 'A' */ && ch <= 0x5A  /* 'Z' */) ||\n            (ch >= 0x30  /* '0' */ && ch <= 0x39  /* '9' */);\n    }\n\n    function isParamTitle(title) {\n        return title === 'param' || title === 'argument' || title === 'arg';\n    }\n\n    function isReturnTitle(title) {\n        return title === 'return' || title === 'returns';\n    }\n\n    function isProperty(title) {\n        return title === 'property' || title === 'prop';\n    }\n\n    function isNameParameterRequired(title) {\n        return isParamTitle(title) || isProperty(title) ||\n            title === 'alias' || title === 'this' || title === 'mixes' || title === 'requires';\n    }\n\n    function isAllowedName(title) {\n        return isNameParameterRequired(title) || title === 'const' || title === 'constant';\n    }\n\n    function isAllowedNested(title) {\n        return isProperty(title) || isParamTitle(title);\n    }\n\n    function isAllowedOptional(title) {\n        return isProperty(title) || isParamTitle(title);\n    }\n\n    function isTypeParameterRequired(title) {\n        return isParamTitle(title) || isReturnTitle(title) ||\n            title === 'define' || title === 'enum' ||\n            title === 'implements' || title === 'this' ||\n            title === 'type' || title === 'typedef' || isProperty(title);\n    }\n\n    // Consider deprecation instead using 'isTypeParameterRequired' and 'Rules' declaration to pick when a type is optional/required\n    // This would require changes to 'parseType'\n    function isAllowedType(title) {\n        return isTypeParameterRequired(title) || title === 'throws' || title === 'const' || title === 'constant' ||\n            title === 'namespace' || title === 'member' || title === 'var' || title === 'module' ||\n            title === 'constructor' || title === 'class' || title === 'extends' || title === 'augments' ||\n            title === 'public' || title === 'private' || title === 'protected';\n    }\n\n    // A regex character class that contains all whitespace except linebreak characters (\\r, \\n, \\u2028, \\u2029)\n    var WHITESPACE = '[ \\\\f\\\\t\\\\v\\\\u00a0\\\\u1680\\\\u180e\\\\u2000-\\\\u200a\\\\u202f\\\\u205f\\\\u3000\\\\ufeff]';\n\n    var STAR_MATCHER = '(' + WHITESPACE + '*(?:\\\\*' + WHITESPACE + '?)?)(.+|[\\r\\n\\u2028\\u2029])';\n\n    function unwrapComment(doc) {\n        // JSDoc comment is following form\n        //   /**\n        //    * .......\n        //    */\n\n        return doc.\n            // remove /**\n            replace(/^\\/\\*\\*?/, '').\n            // remove */\n            replace(/\\*\\/$/, '').\n            // remove ' * ' at the beginning of a line\n            replace(new RegExp(STAR_MATCHER, 'g'), '$2').\n            // remove trailing whitespace\n            replace(/\\s*$/, '');\n    }\n\n    /**\n     * Converts an index in an \"unwrapped\" JSDoc comment to the corresponding index in the original \"wrapped\" version\n     * @param {string} originalSource The original wrapped comment\n     * @param {number} unwrappedIndex The index of a character in the unwrapped string\n     * @returns {number} The index of the corresponding character in the original wrapped string\n     */\n    function convertUnwrappedCommentIndex(originalSource, unwrappedIndex) {\n        var replacedSource = originalSource.replace(/^\\/\\*\\*?/, '');\n        var numSkippedChars = 0;\n        var matcher = new RegExp(STAR_MATCHER, 'g');\n        var match;\n\n        while ((match = matcher.exec(replacedSource))) {\n            numSkippedChars += match[1].length;\n\n            if (match.index + match[0].length > unwrappedIndex + numSkippedChars) {\n                return unwrappedIndex + numSkippedChars + originalSource.length - replacedSource.length;\n            }\n        }\n\n        return originalSource.replace(/\\*\\/$/, '').replace(/\\s*$/, '').length;\n    }\n\n    // JSDoc Tag Parser\n\n    (function (exports) {\n        var Rules,\n            index,\n            lineNumber,\n            length,\n            source,\n            originalSource,\n            recoverable,\n            sloppy,\n            strict;\n\n        function advance() {\n            var ch = source.charCodeAt(index);\n            index += 1;\n            if (esutils.code.isLineTerminator(ch) && !(ch === 0x0D  /* '\\r' */ && source.charCodeAt(index) === 0x0A  /* '\\n' */)) {\n                lineNumber += 1;\n            }\n            return String.fromCharCode(ch);\n        }\n\n        function scanTitle() {\n            var title = '';\n            // waste '@'\n            advance();\n\n            while (index < length && isASCIIAlphanumeric(source.charCodeAt(index))) {\n                title += advance();\n            }\n\n            return title;\n        }\n\n        function seekContent() {\n            var ch, waiting, last = index;\n\n            waiting = false;\n            while (last < length) {\n                ch = source.charCodeAt(last);\n                if (esutils.code.isLineTerminator(ch) && !(ch === 0x0D  /* '\\r' */ && source.charCodeAt(last + 1) === 0x0A  /* '\\n' */)) {\n                    waiting = true;\n                } else if (waiting) {\n                    if (ch === 0x40  /* '@' */) {\n                        break;\n                    }\n                    if (!esutils.code.isWhiteSpace(ch)) {\n                        waiting = false;\n                    }\n                }\n                last += 1;\n            }\n            return last;\n        }\n\n        // type expression may have nest brace, such as,\n        // { { ok: string } }\n        //\n        // therefore, scanning type expression with balancing braces.\n        function parseType(title, last, addRange) {\n            var ch, brace, type, startIndex, direct = false;\n\n\n            // search '{'\n            while (index < last) {\n                ch = source.charCodeAt(index);\n                if (esutils.code.isWhiteSpace(ch)) {\n                    advance();\n                } else if (ch === 0x7B  /* '{' */) {\n                    advance();\n                    break;\n                } else {\n                    // this is direct pattern\n                    direct = true;\n                    break;\n                }\n            }\n\n\n            if (direct) {\n                return null;\n            }\n\n            // type expression { is found\n            brace = 1;\n            type = '';\n            while (index < last) {\n                ch = source.charCodeAt(index);\n                if (esutils.code.isLineTerminator(ch)) {\n                    advance();\n                } else {\n                    if (ch === 0x7D  /* '}' */) {\n                        brace -= 1;\n                        if (brace === 0) {\n                            advance();\n                            break;\n                        }\n                    } else if (ch === 0x7B  /* '{' */) {\n                        brace += 1;\n                    }\n                    if (type === '') {\n                        startIndex = index;\n                    }\n                    type += advance();\n                }\n            }\n\n            if (brace !== 0) {\n                // braces is not balanced\n                return utility.throwError('Braces are not balanced');\n            }\n\n            if (isAllowedOptional(title)) {\n                return typed.parseParamType(type, {startIndex: convertIndex(startIndex), range: addRange});\n            }\n\n            return typed.parseType(type, {startIndex: convertIndex(startIndex), range: addRange});\n        }\n\n        function scanIdentifier(last) {\n            var identifier;\n            if (!esutils.code.isIdentifierStartES5(source.charCodeAt(index)) && !source[index].match(/[0-9]/)) {\n                return null;\n            }\n            identifier = advance();\n            while (index < last && esutils.code.isIdentifierPartES5(source.charCodeAt(index))) {\n                identifier += advance();\n            }\n            return identifier;\n        }\n\n        function skipWhiteSpace(last) {\n            while (index < last && (esutils.code.isWhiteSpace(source.charCodeAt(index)) || esutils.code.isLineTerminator(source.charCodeAt(index)))) {\n                advance();\n            }\n        }\n\n        function parseName(last, allowBrackets, allowNestedParams) {\n            var name = '',\n                useBrackets,\n                insideString;\n\n\n            skipWhiteSpace(last);\n\n            if (index >= last) {\n                return null;\n            }\n\n            if (source.charCodeAt(index) === 0x5B  /* '[' */) {\n                if (allowBrackets) {\n                    useBrackets = true;\n                    name = advance();\n                } else {\n                    return null;\n                }\n            }\n\n            name += scanIdentifier(last);\n\n            if (allowNestedParams) {\n                if (source.charCodeAt(index) === 0x3A /* ':' */ && (\n                        name === 'module' ||\n                        name === 'external' ||\n                        name === 'event')) {\n                    name += advance();\n                    name += scanIdentifier(last);\n\n                }\n                if(source.charCodeAt(index) === 0x5B  /* '[' */ && source.charCodeAt(index + 1) === 0x5D  /* ']' */){\n                    name += advance();\n                    name += advance();\n                }\n                while (source.charCodeAt(index) === 0x2E  /* '.' */ ||\n                        source.charCodeAt(index) === 0x2F  /* '/' */ ||\n                        source.charCodeAt(index) === 0x23  /* '#' */ ||\n                        source.charCodeAt(index) === 0x2D  /* '-' */ ||\n                        source.charCodeAt(index) === 0x7E  /* '~' */) {\n                    name += advance();\n                    name += scanIdentifier(last);\n                }\n            }\n\n            if (useBrackets) {\n                skipWhiteSpace(last);\n                // do we have a default value for this?\n                if (source.charCodeAt(index) === 0x3D  /* '=' */) {\n                    // consume the '='' symbol\n                    name += advance();\n                    skipWhiteSpace(last);\n\n                    var ch;\n                    var bracketDepth = 1;\n\n                    // scan in the default value\n                    while (index < last) {\n                        ch = source.charCodeAt(index);\n\n                        if (esutils.code.isWhiteSpace(ch)) {\n                            if (!insideString) {\n                                skipWhiteSpace(last);\n                                ch = source.charCodeAt(index);\n                            }\n                        }\n\n                        if (ch === 0x27 /* ''' */) {\n                            if (!insideString) {\n                                insideString = '\\'';\n                            } else {\n                                if (insideString === '\\'') {\n                                    insideString = '';\n                                }\n                            }\n                        }\n\n                        if (ch === 0x22 /* '\"' */) {\n                            if (!insideString) {\n                                insideString = '\"';\n                            } else {\n                                if (insideString === '\"') {\n                                    insideString = '';\n                                }\n                            }\n                        }\n\n                        if (ch === 0x5B /* '[' */) {\n                            bracketDepth++;\n                        } else if (ch === 0x5D  /* ']' */ &&\n                            --bracketDepth === 0) {\n                            break;\n                        }\n\n                        name += advance();\n                    }\n                }\n\n                skipWhiteSpace(last);\n\n                if (index >= last || source.charCodeAt(index) !== 0x5D  /* ']' */) {\n                    // we never found a closing ']'\n                    return null;\n                }\n\n                // collect the last ']'\n                name += advance();\n            }\n\n            return name;\n        }\n\n        function skipToTag() {\n            while (index < length && source.charCodeAt(index) !== 0x40  /* '@' */) {\n                advance();\n            }\n            if (index >= length) {\n                return false;\n            }\n            utility.assert(source.charCodeAt(index) === 0x40  /* '@' */);\n            return true;\n        }\n\n        function convertIndex(rangeIndex) {\n            if (source === originalSource) {\n                return rangeIndex;\n            }\n            return convertUnwrappedCommentIndex(originalSource, rangeIndex);\n        }\n\n        function TagParser(options, title) {\n            this._options = options;\n            this._title = title.toLowerCase();\n            this._tag = {\n                title: title,\n                description: null\n            };\n            if (this._options.lineNumbers) {\n                this._tag.lineNumber = lineNumber;\n            }\n            this._first = index - title.length - 1;\n            this._last = 0;\n            // space to save special information for title parsers.\n            this._extra = { };\n        }\n\n        // addError(err, ...)\n        TagParser.prototype.addError = function addError(errorText) {\n            var args = Array.prototype.slice.call(arguments, 1),\n                msg = errorText.replace(\n                    /%(\\d)/g,\n                    function (whole, index) {\n                        utility.assert(index < args.length, 'Message reference must be in range');\n                        return args[index];\n                    }\n                );\n\n            if (!this._tag.errors) {\n                this._tag.errors = [];\n            }\n            if (strict) {\n                utility.throwError(msg);\n            }\n            this._tag.errors.push(msg);\n            return recoverable;\n        };\n\n        TagParser.prototype.parseType = function () {\n            // type required titles\n            if (isTypeParameterRequired(this._title)) {\n                try {\n                    this._tag.type = parseType(this._title, this._last, this._options.range);\n                    if (!this._tag.type) {\n                        if (!isParamTitle(this._title) && !isReturnTitle(this._title)) {\n                            if (!this.addError('Missing or invalid tag type')) {\n                                return false;\n                            }\n                        }\n                    }\n                } catch (error) {\n                    this._tag.type = null;\n                    if (!this.addError(error.message)) {\n                        return false;\n                    }\n                }\n            } else if (isAllowedType(this._title)) {\n                // optional types\n                try {\n                    this._tag.type = parseType(this._title, this._last, this._options.range);\n                } catch (e) {\n                    //For optional types, lets drop the thrown error when we hit the end of the file\n                }\n            }\n            return true;\n        };\n\n        TagParser.prototype._parseNamePath = function (optional) {\n            var name;\n            name = parseName(this._last, sloppy && isAllowedOptional(this._title), true);\n            if (!name) {\n                if (!optional) {\n                    if (!this.addError('Missing or invalid tag name')) {\n                        return false;\n                    }\n                }\n            }\n            this._tag.name = name;\n            return true;\n        };\n\n        TagParser.prototype.parseNamePath = function () {\n            return this._parseNamePath(false);\n        };\n\n        TagParser.prototype.parseNamePathOptional = function () {\n            return this._parseNamePath(true);\n        };\n\n\n        TagParser.prototype.parseName = function () {\n            var assign, name;\n\n            // param, property requires name\n            if (isAllowedName(this._title)) {\n                this._tag.name = parseName(this._last, sloppy && isAllowedOptional(this._title), isAllowedNested(this._title));\n                if (!this._tag.name) {\n                    if (!isNameParameterRequired(this._title)) {\n                        return true;\n                    }\n\n                    // it's possible the name has already been parsed but interpreted as a type\n                    // it's also possible this is a sloppy declaration, in which case it will be\n                    // fixed at the end\n                    if (isParamTitle(this._title) && this._tag.type && this._tag.type.name) {\n                        this._extra.name = this._tag.type;\n                        this._tag.name = this._tag.type.name;\n                        this._tag.type = null;\n                    } else {\n                        if (!this.addError('Missing or invalid tag name')) {\n                            return false;\n                        }\n                    }\n                } else {\n                    name = this._tag.name;\n                    if (name.charAt(0) === '[' && name.charAt(name.length - 1) === ']') {\n                        // extract the default value if there is one\n                        // example: @param {string} [somebody=John Doe] description\n                        assign = name.substring(1, name.length - 1).split('=');\n                        if (assign.length > 1) {\n                            this._tag['default'] = assign.slice(1).join('=');\n                        }\n                        this._tag.name = assign[0];\n\n                        // convert to an optional type\n                        if (this._tag.type && this._tag.type.type !== 'OptionalType') {\n                            this._tag.type = {\n                                type: 'OptionalType',\n                                expression: this._tag.type\n                            };\n                        }\n                    }\n                }\n            }\n\n\n            return true;\n        };\n\n        TagParser.prototype.parseDescription = function parseDescription() {\n            var description = sliceSource(source, index, this._last).trim();\n            if (description) {\n                if ((/^-\\s+/).test(description)) {\n                    description = description.substring(2);\n                }\n                this._tag.description = description;\n            }\n            return true;\n        };\n\n        TagParser.prototype.parseCaption = function parseDescription() {\n            var description = sliceSource(source, index, this._last).trim();\n            var captionStartTag = '<caption>';\n            var captionEndTag = '</caption>';\n            var captionStart = description.indexOf(captionStartTag);\n            var captionEnd = description.indexOf(captionEndTag);\n            if (captionStart >= 0 && captionEnd >= 0) {\n                this._tag.caption = description.substring(\n                    captionStart + captionStartTag.length, captionEnd).trim();\n                this._tag.description = description.substring(captionEnd + captionEndTag.length).trim();\n            } else {\n                this._tag.description = description;\n            }\n            return true;\n        };\n\n        TagParser.prototype.parseKind = function parseKind() {\n            var kind, kinds;\n            kinds = {\n                'class': true,\n                'constant': true,\n                'event': true,\n                'external': true,\n                'file': true,\n                'function': true,\n                'member': true,\n                'mixin': true,\n                'module': true,\n                'namespace': true,\n                'typedef': true\n            };\n            kind = sliceSource(source, index, this._last).trim();\n            this._tag.kind = kind;\n            if (!hasOwnProperty(kinds, kind)) {\n                if (!this.addError('Invalid kind name \\'%0\\'', kind)) {\n                    return false;\n                }\n            }\n            return true;\n        };\n\n        TagParser.prototype.parseAccess = function parseAccess() {\n            var access;\n            access = sliceSource(source, index, this._last).trim();\n            this._tag.access = access;\n            if (access !== 'private' && access !== 'protected' && access !== 'public') {\n                if (!this.addError('Invalid access name \\'%0\\'', access)) {\n                    return false;\n                }\n            }\n            return true;\n        };\n\n        TagParser.prototype.parseThis = function parseThis() {\n            // this name may be a name expression (e.g. {foo.bar}),\n            // an union (e.g. {foo.bar|foo.baz}) or a name path (e.g. foo.bar)\n            var value = sliceSource(source, index, this._last).trim();\n            if (value && value.charAt(0) === '{') {\n                var gotType = this.parseType();\n                if (gotType && this._tag.type.type === 'NameExpression' || this._tag.type.type === 'UnionType') {\n                    this._tag.name = this._tag.type.name;\n                    return true;\n                } else {\n                    return this.addError('Invalid name for this');\n                }\n            } else {\n                return this.parseNamePath();\n            }\n        };\n\n        TagParser.prototype.parseVariation = function parseVariation() {\n            var variation, text;\n            text = sliceSource(source, index, this._last).trim();\n            variation = parseFloat(text, 10);\n            this._tag.variation = variation;\n            if (isNaN(variation)) {\n                if (!this.addError('Invalid variation \\'%0\\'', text)) {\n                    return false;\n                }\n            }\n            return true;\n        };\n\n        TagParser.prototype.ensureEnd = function () {\n            var shouldBeEmpty = sliceSource(source, index, this._last).trim();\n            if (shouldBeEmpty) {\n                if (!this.addError('Unknown content \\'%0\\'', shouldBeEmpty)) {\n                    return false;\n                }\n            }\n            return true;\n        };\n\n        TagParser.prototype.epilogue = function epilogue() {\n            var description;\n\n            description = this._tag.description;\n            // un-fix potentially sloppy declaration\n            if (isAllowedOptional(this._title) && !this._tag.type && description && description.charAt(0) === '[') {\n                this._tag.type = this._extra.name;\n                if (!this._tag.name) {\n                    this._tag.name = undefined;\n                }\n\n                if (!sloppy) {\n                    if (!this.addError('Missing or invalid tag name')) {\n                        return false;\n                    }\n                }\n            }\n\n            return true;\n        };\n\n        Rules = {\n            // http://usejsdoc.org/tags-access.html\n            'access': ['parseAccess'],\n            // http://usejsdoc.org/tags-alias.html\n            'alias': ['parseNamePath', 'ensureEnd'],\n            // http://usejsdoc.org/tags-augments.html\n            'augments': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\n            // http://usejsdoc.org/tags-constructor.html\n            'constructor': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\n            // Synonym: http://usejsdoc.org/tags-constructor.html\n            'class': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\n            // Synonym: http://usejsdoc.org/tags-extends.html\n            'extends': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\n            // http://usejsdoc.org/tags-example.html\n            'example': ['parseCaption'],\n            // http://usejsdoc.org/tags-deprecated.html\n            'deprecated': ['parseDescription'],\n            // http://usejsdoc.org/tags-global.html\n            'global': ['ensureEnd'],\n            // http://usejsdoc.org/tags-inner.html\n            'inner': ['ensureEnd'],\n            // http://usejsdoc.org/tags-instance.html\n            'instance': ['ensureEnd'],\n            // http://usejsdoc.org/tags-kind.html\n            'kind': ['parseKind'],\n            // http://usejsdoc.org/tags-mixes.html\n            'mixes': ['parseNamePath', 'ensureEnd'],\n            // http://usejsdoc.org/tags-mixin.html\n            'mixin': ['parseNamePathOptional', 'ensureEnd'],\n            // http://usejsdoc.org/tags-member.html\n            'member': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\n            // http://usejsdoc.org/tags-method.html\n            'method': ['parseNamePathOptional', 'ensureEnd'],\n            // http://usejsdoc.org/tags-module.html\n            'module': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\n            // Synonym: http://usejsdoc.org/tags-method.html\n            'func': ['parseNamePathOptional', 'ensureEnd'],\n            // Synonym: http://usejsdoc.org/tags-method.html\n            'function': ['parseNamePathOptional', 'ensureEnd'],\n            // Synonym: http://usejsdoc.org/tags-member.html\n            'var': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\n            // http://usejsdoc.org/tags-name.html\n            'name': ['parseNamePath', 'ensureEnd'],\n            // http://usejsdoc.org/tags-namespace.html\n            'namespace': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\n            // http://usejsdoc.org/tags-private.html\n            'private': ['parseType', 'parseDescription'],\n            // http://usejsdoc.org/tags-protected.html\n            'protected': ['parseType', 'parseDescription'],\n            // http://usejsdoc.org/tags-public.html\n            'public': ['parseType', 'parseDescription'],\n            // http://usejsdoc.org/tags-readonly.html\n            'readonly': ['ensureEnd'],\n            // http://usejsdoc.org/tags-requires.html\n            'requires': ['parseNamePath', 'ensureEnd'],\n            // http://usejsdoc.org/tags-since.html\n            'since': ['parseDescription'],\n            // http://usejsdoc.org/tags-static.html\n            'static': ['ensureEnd'],\n            // http://usejsdoc.org/tags-summary.html\n            'summary': ['parseDescription'],\n            // http://usejsdoc.org/tags-this.html\n            'this': ['parseThis', 'ensureEnd'],\n            // http://usejsdoc.org/tags-todo.html\n            'todo': ['parseDescription'],\n            // http://usejsdoc.org/tags-typedef.html\n            'typedef': ['parseType', 'parseNamePathOptional'],\n            // http://usejsdoc.org/tags-variation.html\n            'variation': ['parseVariation'],\n            // http://usejsdoc.org/tags-version.html\n            'version': ['parseDescription']\n        };\n\n        TagParser.prototype.parse = function parse() {\n            var i, iz, sequences, method;\n\n\n            // empty title\n            if (!this._title) {\n                if (!this.addError('Missing or invalid title')) {\n                    return null;\n                }\n            }\n\n            // Seek to content last index.\n            this._last = seekContent(this._title);\n\n            if (this._options.range) {\n                this._tag.range = [this._first, source.slice(0, this._last).replace(/\\s*$/, '').length].map(convertIndex);\n            }\n\n            if (hasOwnProperty(Rules, this._title)) {\n                sequences = Rules[this._title];\n            } else {\n                // default sequences\n                sequences = ['parseType', 'parseName', 'parseDescription', 'epilogue'];\n            }\n\n            for (i = 0, iz = sequences.length; i < iz; ++i) {\n                method = sequences[i];\n                if (!this[method]()) {\n                    return null;\n                }\n            }\n\n            return this._tag;\n        };\n\n        function parseTag(options) {\n            var title, parser, tag;\n\n            // skip to tag\n            if (!skipToTag()) {\n                return null;\n            }\n\n            // scan title\n            title = scanTitle();\n\n            // construct tag parser\n            parser = new TagParser(options, title);\n            tag = parser.parse();\n\n            // Seek global index to end of this tag.\n            while (index < parser._last) {\n                advance();\n            }\n\n            return tag;\n        }\n\n        //\n        // Parse JSDoc\n        //\n\n        function scanJSDocDescription(preserveWhitespace) {\n            var description = '', ch, atAllowed;\n\n            atAllowed = true;\n            while (index < length) {\n                ch = source.charCodeAt(index);\n\n                if (atAllowed && ch === 0x40  /* '@' */) {\n                    break;\n                }\n\n                if (esutils.code.isLineTerminator(ch)) {\n                    atAllowed = true;\n                } else if (atAllowed && !esutils.code.isWhiteSpace(ch)) {\n                    atAllowed = false;\n                }\n\n                description += advance();\n            }\n\n            return preserveWhitespace ? description : description.trim();\n        }\n\n        function parse(comment, options) {\n            var tags = [], tag, description, interestingTags, i, iz;\n\n            if (options === undefined) {\n                options = {};\n            }\n\n            if (typeof options.unwrap === 'boolean' && options.unwrap) {\n                source = unwrapComment(comment);\n            } else {\n                source = comment;\n            }\n\n            originalSource = comment;\n\n            // array of relevant tags\n            if (options.tags) {\n                if (Array.isArray(options.tags)) {\n                    interestingTags = { };\n                    for (i = 0, iz = options.tags.length; i < iz; i++) {\n                        if (typeof options.tags[i] === 'string') {\n                            interestingTags[options.tags[i]] = true;\n                        } else {\n                            utility.throwError('Invalid \"tags\" parameter: ' + options.tags);\n                        }\n                    }\n                } else {\n                    utility.throwError('Invalid \"tags\" parameter: ' + options.tags);\n                }\n            }\n\n            length = source.length;\n            index = 0;\n            lineNumber = 0;\n            recoverable = options.recoverable;\n            sloppy = options.sloppy;\n            strict = options.strict;\n\n            description = scanJSDocDescription(options.preserveWhitespace);\n\n            while (true) {\n                tag = parseTag(options);\n                if (!tag) {\n                    break;\n                }\n                if (!interestingTags || interestingTags.hasOwnProperty(tag.title)) {\n                    tags.push(tag);\n                }\n            }\n\n            return {\n                description: description,\n                tags: tags\n            };\n        }\n        exports.parse = parse;\n    }(jsdoc = {}));\n\n    exports.version = utility.VERSION;\n    exports.parse = jsdoc.parse;\n    exports.parseType = typed.parseType;\n    exports.parseParamType = typed.parseParamType;\n    exports.unwrapComment = unwrapComment;\n    exports.Syntax = shallowCopy(typed.Syntax);\n    exports.Error = utility.DoctrineError;\n    exports.type = {\n        Syntax: exports.Syntax,\n        parseType: typed.parseType,\n        parseParamType: typed.parseParamType,\n        stringify: typed.stringify\n    };\n}());\n/* vim: set sw=4 ts=4 et tw=80 : */\n"],"names":["VERSION","require$$0","utility","DoctrineError","message","Middle","throwError","require$$1","Syntax","Token","source","length","index","previous","token","value","esutils","rangeOffset","addRange","isTypeName","ch","Context","maybeAddRange","node","range","advance","scanHexEscape","prefix","i","len","code","scanString","str","quote","unescaped","restore","scanNumber","number","scanTypeName","ch2","next","consume","target","text","expect","parseUnionType","elements","startIndex","parseTypeExpression","parseArrayType","restStartIndex","parseFieldName","v","parseFieldType","key","rangeStart","parseRecordType","fields","rangeEnd","parseNameExpression","name","parseTypeExpressionList","parseTop","parseTypeName","expr","applications","parseResultType","parseParametersType","params","optionalSequence","rest","nameStartIndex","parseFunctionType","isNew","thisBinding","result","fnType","parseBasicTypeExpression","context","parseTopParamType","parseType","src","opt","parseParamType","stringifyImpl","compact","topLevel","iz","stringify","options","typed","jsdoc","hasOwnProperty","require$$2","sliceSource","last","func","obj","shallowCopy","ret","isASCIIAlphanumeric","isParamTitle","title","isReturnTitle","isProperty","isNameParameterRequired","isAllowedName","isAllowedNested","isAllowedOptional","isTypeParameterRequired","isAllowedType","WHITESPACE","STAR_MATCHER","unwrapComment","doc","convertUnwrappedCommentIndex","originalSource","unwrappedIndex","replacedSource","numSkippedChars","matcher","match","exports","Rules","lineNumber","recoverable","sloppy","strict","scanTitle","seekContent","waiting","brace","type","direct","convertIndex","scanIdentifier","identifier","skipWhiteSpace","parseName","allowBrackets","allowNestedParams","useBrackets","insideString","bracketDepth","skipToTag","rangeIndex","TagParser","errorText","args","msg","whole","error","optional","assign","description","captionStartTag","captionEndTag","captionStart","captionEnd","kind","kinds","access","gotType","variation","shouldBeEmpty","sequences","method","parseTag","parser","tag","scanJSDocDescription","preserveWhitespace","atAllowed","parse","comment","tags","interestingTags"],"mappings":"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","x_google_ignoreList":[0,1,2]}